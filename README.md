# Learning Management System (LMS)

## Загальний опис

Проєкт є веб-орієнтованою системою управління навчанням (LMS), розробленою для створення, розповсюдження та контролю проходження навчальних курсів. Система забезпечує взаємодію між двома ключовими групами користувачів: викладачами (авторами контенту) та студентами (споживачами контенту).

Основна мета проєкту — надати зручний інструментарій для організації дистанційного навчання з можливістю моніторингу успішності студентів.

## Функціональні вимоги та модулі

### 1. Модуль авторизації та користувачів

Система підтримує рольову модель доступу (RBAC):

- **Студент:** має доступ до каталогу курсів, особистого кабінету та інтерфейсу проходження уроків.
- **Викладач/Адміністратор:** має права на створення курсів, редагування матеріалів та перегляд аналітики.
  Безпека забезпечується через JWT (JSON Web Tokens).

### 2. Управління навчальним контентом (Course Management)

Викладачі мають можливість:

- Створювати нові курси з метаданими (назва, опис, категорія, рівень складності).
- Структурувати курс за модулями та уроками.
- Додавати мультимедійний контент (відео-лекції, текстові матеріали).

### 3. Навчальний процес (Learning Engine)

Інтерфейс студента включає:

- Відеоплеєр для перегляду лекцій.
- Система відстеження прогресу (Progress Tracking): автоматична фіксація переглянутих матеріалів.
- Розрахунок відсотка завершення курсу.

## Технічний стек

Проєкт реалізовано з використанням архітектури клієнт-сервер (REST API).

### Клієнтська частина (Frontend)

- **Framework:** React
- **Language:** TypeScript
- **Build Tool:** Vite
- **Styling:** TailwindCSS (для забезпечення адаптивності інтерфейсу)
- **State Management:** React Context API / Custom Hooks

### Серверна частина (Backend)

- **Runtime:** Node.js
- **Framework:** Express.js
- **Language:** TypeScript
- **Architecture:** Layered Architecture (Controllers, Services, Data Access)

### Інструменти розробки та контролю якості (DevTools)

- **Linter:** ESLint (аналіз статичного коду)
- **Formatter:** Prettier (уніфікація стилю коду)
- **VCS Hooks:** Husky (автоматизація перевірок перед комітом та пушем)

## Структура репозиторію

Проєкт організовано за принципом монорепозиторію:

- `/client` — вихідний код інтерфейсу користувача.
- `/server` — вихідний код серверної частини API.
- `package.json` — конфігурація скриптів для управління всім проєктом.

## Інструкція з розгортання

Для локального запуску проєкту необхідно виконати наступні кроки:

1. Клонування репозиторію:

   ```bash
   git clone <URL_репозиторію>
   ```

2. Встановлення залежностей:

   ```bash
   npm install
   cd client && npm install
   cd ../server && npm install
   ```

3. Запуск проєкту (режим розробки):
   - Клієнт:
     ```bash
     cd client
     npm run dev
     ```
   - Сервер:
     ```bash
     cd server
     npm run dev
     ```

## 3. Архітектура та структура даних (Лабораторна робота №2)

### Діаграма компонентів (Component Diagram)
Відображає взаємодію між клієнтською частиною, API шлюзом та базою даних.

![](/image/1234.png)

### Схема бази даних (ER Diagram)
Опис сутностей системи: Користувачі, Курси, Модулі, Уроки та Прогрес.

![](/image/123.png) 

### Сценарій взаємодії (Use Case: Завершення уроку)
1. Користувач натискає кнопку "Завершити урок" в інтерфейсі.
2. Клієнт відправляє POST запит на сервер з ідентифікатором уроку.
3. Сервер перевіряє права доступу (JWT).
4. Сервер створює запис у таблиці Progress.
5. Сервер повертає оновлений статус, клієнт відображає зелену відмітку.

## Інструкція із запуску

### 1. Сервер (Backend)
Відкрийте термінал, перейдіть у папку `server` та запустіть API:

```bash
cd server
npm install
npm run dev
```

Сервер запуститься на: `http://localhost:3000`

### 2. Клієнт (Frontend)
Відкрийте **новий** термінал, перейдіть у папку `client` та запустіть інтерфейс:

```bash
cd client
npm install
npm run dev
```

Відкрийте посилання у браузері (зазвичай `http://localhost:5173`).

## Інтерфейс Prisma Studio, що демонструє наповнену таблицю Lesson у віддаленій базі даних (Neon).
![](/image/12345.png) 

##  Тестування (Lab 5)
У проєкті реалізовано піраміду тестування.

### Unit та Integration тести (Backend)
Перевіряють бізнес-логіку (розрахунок тривалості, прогресу) та API ендпоінти.

```bash
cd server
npm test
```

### End-to-End тести (Frontend)
Імітують дії реального користувача у браузері (Playwright).
*Важливо: Сервер та Клієнт мають бути запущені перед тестом.*

```bash
cd client
npx playwright test
```

---
Звіт про тестування 
1. Покриття коду ффів
Реалізовано повну піраміду тестування:
- Unit (Jest): Перевірено бізнес-логіку розрахунку тривалості та прогресу (100% покриття утиліт). 
- Integration (Supertest): Перевірено роботу REST API ендпоінтів та їх взаємодію з БД.
- E2E (Playwright): Перевірено критичний шлях користувача (відкриття Dashboard → вхід у Курс).
2. ЕфективністьІ
Тести інтегровані в CI/CD pipeline. Завдяки цьому жоден несправний код не потрапляє в репозиторій. Unit-тести виконуються миттєво (<1с), що не сповільнює розробку.
3. Що покращити
Додати мутаційне тестування, щоб перевірити якість написаних тестів ("тестування тестів").
Розширити E2E сценарії на випадок помилок мереж

## Performance & Load Testing (Lab 7)
### Аналіз клієнтської частини

![](/image/123456.png) 

### Навантажувальне тестування API
Виконано стрес-тестування API (GET /api/courses) за допомогою утиліти Autocannon.
Параметри: 100 одночасних підключень, тривалість 10 секунд.
Команда: npm run test:load

![](/image/12.png) 

# Лабораторна робота №8 (Рефакторинг)

**Тема:** Винесення коду та оптимізація архітектури.

**1. Пошук проблеми (Bottleneck)**
Проаналізував проєкт після навантажувального тестування. Найбільш вразливим місцем був файл `app.ts`.
**Проблема:** "Fat Controller" (Товстий контролер). В одному файлі було змішано все: налаштування Express, прямі запити до БД через Prisma і математика розрахунку відсотків проходження курсу. Читати і підтримувати це стало складно.

**2. Винесення логіки (Extraction)**
Створив окремий шар сервісів (`Layered Architecture`), щоб розвантажити контролер.
*   Створив файл: `server/src/services/course.service.ts`.
*   Створив клас: `CourseService`.
*   Переніс туди методи `getAllCoursesWithProgress` та `getCourseById`. Тепер контролер не знає, як рахуються відсотки, він просто отримує готовий результат.

**3. Dependency Injection (DI)**
Реалізував впровадження залежностей.
*   Сервіс не імпортує `prisma` глобально.
*   Замість цього він приймає екземпляр `PrismaClient` у свій **конструктор**.
*   Це дозволяє при необхідності легко підмінити базу даних (наприклад, для тестів).

**4. Результат**
*   Файл `app.ts` став чистішим в 2 рази.
*   Логіка інкапсульована в сервісі.
*   Запустив `npm test` — інтеграційні та Unit-тести пройшли успішно, рефакторинг нічого не зламав.